//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.0.0 (NJsonSchema v10.7.1.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

import * as moment from 'moment';

export interface IChatClient {
    getChats(): Promise<MessengerChatDto[]>;
    getChatById(chatId: string): Promise<MessengerChatDto>;
    getUserIdsByChatId(chatId: string): Promise<string[]>;
    addChannel(userId: string, name: string | null, description: string | null): Promise<void>;
    addGroupChat(userId: string, name: string | null, description: string | null): Promise<void>;
    addPersonalChat(firstUserId: string, secondUserId: string, name: string | null, description: string | null): Promise<void>;
    addSavedMessages(userId: string, name: string | null, description: string | null): Promise<void>;
    addUserToChat(userId: string, chatId: string): Promise<void>;
    deleteUserToChat(userId: string, chatId: string): Promise<void>;
}

export class ChatClient implements IChatClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    getChats(  cancelToken?: CancelToken | undefined): Promise<MessengerChatDto[]> {
        let url_ = this.baseUrl + "/api/Chat/GetChats";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetChats(_response);
        });
    }

    protected processGetChats(response: AxiosResponse): Promise<MessengerChatDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MessengerChatDto.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<MessengerChatDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MessengerChatDto[]>(null as any);
    }

    getChatById(chatId: string , cancelToken?: CancelToken | undefined): Promise<MessengerChatDto> {
        let url_ = this.baseUrl + "/api/Chat/GetChatById?";
        if (chatId === undefined || chatId === null)
            throw new Error("The parameter 'chatId' must be defined and cannot be null.");
        else
            url_ += "chatId=" + encodeURIComponent("" + chatId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetChatById(_response);
        });
    }

    protected processGetChatById(response: AxiosResponse): Promise<MessengerChatDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MessengerChatDto.fromJS(resultData200, _mappings);
            return Promise.resolve<MessengerChatDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MessengerChatDto>(null as any);
    }

    getUserIdsByChatId(chatId: string , cancelToken?: CancelToken | undefined): Promise<string[]> {
        let url_ = this.baseUrl + "/api/Chat/GetUserIdsByChatId?";
        if (chatId === undefined || chatId === null)
            throw new Error("The parameter 'chatId' must be defined and cannot be null.");
        else
            url_ += "chatId=" + encodeURIComponent("" + chatId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetUserIdsByChatId(_response);
        });
    }

    protected processGetUserIdsByChatId(response: AxiosResponse): Promise<string[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<string[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string[]>(null as any);
    }

    addChannel(userId: string, name: string | null, description: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Chat/AddChannel?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (name === undefined)
            throw new Error("The parameter 'name' must be defined.");
        else if(name !== null)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (description === undefined)
            throw new Error("The parameter 'description' must be defined.");
        else if(description !== null)
            url_ += "description=" + encodeURIComponent("" + description) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddChannel(_response);
        });
    }

    protected processAddChannel(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    addGroupChat(userId: string, name: string | null, description: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Chat/AddGroupChat?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (name === undefined)
            throw new Error("The parameter 'name' must be defined.");
        else if(name !== null)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (description === undefined)
            throw new Error("The parameter 'description' must be defined.");
        else if(description !== null)
            url_ += "description=" + encodeURIComponent("" + description) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddGroupChat(_response);
        });
    }

    protected processAddGroupChat(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    addPersonalChat(firstUserId: string, secondUserId: string, name: string | null, description: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Chat/AddPersonalChat?";
        if (firstUserId === undefined || firstUserId === null)
            throw new Error("The parameter 'firstUserId' must be defined and cannot be null.");
        else
            url_ += "firstUserId=" + encodeURIComponent("" + firstUserId) + "&";
        if (secondUserId === undefined || secondUserId === null)
            throw new Error("The parameter 'secondUserId' must be defined and cannot be null.");
        else
            url_ += "secondUserId=" + encodeURIComponent("" + secondUserId) + "&";
        if (name === undefined)
            throw new Error("The parameter 'name' must be defined.");
        else if(name !== null)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (description === undefined)
            throw new Error("The parameter 'description' must be defined.");
        else if(description !== null)
            url_ += "description=" + encodeURIComponent("" + description) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddPersonalChat(_response);
        });
    }

    protected processAddPersonalChat(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    addSavedMessages(userId: string, name: string | null, description: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Chat/AddSavedMessages?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (name === undefined)
            throw new Error("The parameter 'name' must be defined.");
        else if(name !== null)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (description === undefined)
            throw new Error("The parameter 'description' must be defined.");
        else if(description !== null)
            url_ += "description=" + encodeURIComponent("" + description) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddSavedMessages(_response);
        });
    }

    protected processAddSavedMessages(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    addUserToChat(userId: string, chatId: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Chat/AddUserToChat?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (chatId === undefined || chatId === null)
            throw new Error("The parameter 'chatId' must be defined and cannot be null.");
        else
            url_ += "chatId=" + encodeURIComponent("" + chatId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddUserToChat(_response);
        });
    }

    protected processAddUserToChat(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    deleteUserToChat(userId: string, chatId: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Chat/DeleteUserToChat?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (chatId === undefined || chatId === null)
            throw new Error("The parameter 'chatId' must be defined and cannot be null.");
        else
            url_ += "chatId=" + encodeURIComponent("" + chatId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteUserToChat(_response);
        });
    }

    protected processDeleteUserToChat(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export interface IUserClient {
    getAll(): Promise<MessengerUserDto[]>;
    getUser(userId: string): Promise<MessengerUser>;
    getAllChatsByUserId(userId: string): Promise<MessengerChatDto[]>;
    getAllChatsIdByUserId(userId: string): Promise<string[]>;
    getUserRoleByChatId(userId: string, chatId: string): Promise<Role>;
    setNickNameById(userId: string, nickName: string | null): Promise<void>;
    deleteUser(userId: string): Promise<void>;
    addUser(name: string | null, nickName: string | null, description: string | null): Promise<string>;
    changeDescription(userId: string, description: string | null): Promise<void>;
    changeName(userId: string, name: string | null): Promise<void>;
}

export class UserClient implements IUserClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    getAll(  cancelToken?: CancelToken | undefined): Promise<MessengerUserDto[]> {
        let url_ = this.baseUrl + "/api/User/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<MessengerUserDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MessengerUserDto.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<MessengerUserDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MessengerUserDto[]>(null as any);
    }

    getUser(userId: string , cancelToken?: CancelToken | undefined): Promise<MessengerUser> {
        let url_ = this.baseUrl + "/api/User/GetUser?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetUser(_response);
        });
    }

    protected processGetUser(response: AxiosResponse): Promise<MessengerUser> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MessengerUser.fromJS(resultData200, _mappings);
            return Promise.resolve<MessengerUser>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MessengerUser>(null as any);
    }

    getAllChatsByUserId(userId: string , cancelToken?: CancelToken | undefined): Promise<MessengerChatDto[]> {
        let url_ = this.baseUrl + "/api/User/GetAllChatsByUserId?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllChatsByUserId(_response);
        });
    }

    protected processGetAllChatsByUserId(response: AxiosResponse): Promise<MessengerChatDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MessengerChatDto.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<MessengerChatDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MessengerChatDto[]>(null as any);
    }

    getAllChatsIdByUserId(userId: string , cancelToken?: CancelToken | undefined): Promise<string[]> {
        let url_ = this.baseUrl + "/api/User/GetAllChatsIdByUserId?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllChatsIdByUserId(_response);
        });
    }

    protected processGetAllChatsIdByUserId(response: AxiosResponse): Promise<string[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<string[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string[]>(null as any);
    }

    getUserRoleByChatId(userId: string, chatId: string , cancelToken?: CancelToken | undefined): Promise<Role> {
        let url_ = this.baseUrl + "/api/User/GetUserRoleByChatId?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (chatId === undefined || chatId === null)
            throw new Error("The parameter 'chatId' must be defined and cannot be null.");
        else
            url_ += "chatId=" + encodeURIComponent("" + chatId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetUserRoleByChatId(_response);
        });
    }

    protected processGetUserRoleByChatId(response: AxiosResponse): Promise<Role> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Role.fromJS(resultData200, _mappings);
            return Promise.resolve<Role>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Role>(null as any);
    }

    setNickNameById(userId: string, nickName: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/User/SetNickNameById?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (nickName === undefined)
            throw new Error("The parameter 'nickName' must be defined.");
        else if(nickName !== null)
            url_ += "nickName=" + encodeURIComponent("" + nickName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSetNickNameById(_response);
        });
    }

    protected processSetNickNameById(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    deleteUser(userId: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/User/DeleteUser?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteUser(_response);
        });
    }

    protected processDeleteUser(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    addUser(name: string | null, nickName: string | null, description: string | null , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/User/AddUser?";
        if (name === undefined)
            throw new Error("The parameter 'name' must be defined.");
        else if(name !== null)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (nickName === undefined)
            throw new Error("The parameter 'nickName' must be defined.");
        else if(nickName !== null)
            url_ += "nickName=" + encodeURIComponent("" + nickName) + "&";
        if (description === undefined)
            throw new Error("The parameter 'description' must be defined.");
        else if(description !== null)
            url_ += "description=" + encodeURIComponent("" + description) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddUser(_response);
        });
    }

    protected processAddUser(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    changeDescription(userId: string, description: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/User/ChangeDescription?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (description === undefined)
            throw new Error("The parameter 'description' must be defined.");
        else if(description !== null)
            url_ += "description=" + encodeURIComponent("" + description) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeDescription(_response);
        });
    }

    protected processChangeDescription(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    changeName(userId: string, name: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/User/ChangeName?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (name === undefined)
            throw new Error("The parameter 'name' must be defined.");
        else if(name !== null)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeName(_response);
        });
    }

    protected processChangeName(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class MessengerChatDto implements IMessengerChatDto {
    id!: string;
    name!: string | undefined;
    description!: string | undefined;
    creator!: MessengerUserDto | undefined;
    users!: string[];

    constructor(data?: IMessengerChatDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.creator = _data["creator"] ? MessengerUserDto.fromJS(_data["creator"], _mappings) : <any>undefined;
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(item);
            }
        }
    }

    static fromJS(data: any, _mappings?: any): MessengerChatDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<MessengerChatDto>(data, _mappings, MessengerChatDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["creator"] = this.creator ? this.creator.toJSON() : <any>undefined;
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item);
        }
        return data;
    }
}

export interface IMessengerChatDto {
    id: string;
    name: string | undefined;
    description: string | undefined;
    creator: MessengerUserDto | undefined;
    users: string[];
}

export class MessengerUserDto implements IMessengerUserDto {
    id!: string;
    name!: string | undefined;
    nickName!: string | undefined;
    description!: string | undefined;

    constructor(data?: IMessengerUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.nickName = _data["nickName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any, _mappings?: any): MessengerUserDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<MessengerUserDto>(data, _mappings, MessengerUserDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["nickName"] = this.nickName;
        data["description"] = this.description;
        return data;
    }
}

export interface IMessengerUserDto {
    id: string;
    name: string | undefined;
    nickName: string | undefined;
    description: string | undefined;
}

export class MessengerUser implements IMessengerUser {
    id!: string;
    name!: string;
    nickName!: string;
    description!: string;
    chats!: Chat[];

    constructor(data?: IMessengerUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.nickName = _data["nickName"];
            this.description = _data["description"];
            if (Array.isArray(_data["chats"])) {
                this.chats = [] as any;
                for (let item of _data["chats"])
                    this.chats!.push(Chat.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): MessengerUser | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<MessengerUser>(data, _mappings, MessengerUser);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["nickName"] = this.nickName;
        data["description"] = this.description;
        if (Array.isArray(this.chats)) {
            data["chats"] = [];
            for (let item of this.chats)
                data["chats"].push(item.toJSON());
        }
        return data;
    }
}

export interface IMessengerUser {
    id: string;
    name: string;
    nickName: string;
    description: string;
    chats: Chat[];
}

export abstract class Chat implements IChat {
    id!: string;
    name!: string;
    description!: string;
    users!: ChatUser[];
    roles!: Role[];
    maxUsersAmount!: number;
    creatorId!: string;
    creator!: MessengerUser;

    constructor(data?: IChat) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(ChatUser.fromJS(item, _mappings));
            }
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(Role.fromJS(item, _mappings));
            }
            this.maxUsersAmount = _data["maxUsersAmount"];
            this.creatorId = _data["creatorId"];
            this.creator = _data["creator"] ? MessengerUser.fromJS(_data["creator"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): Chat | null {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'Chat' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        data["maxUsersAmount"] = this.maxUsersAmount;
        data["creatorId"] = this.creatorId;
        data["creator"] = this.creator ? this.creator.toJSON() : <any>undefined;
        return data;
    }
}

export interface IChat {
    id: string;
    name: string;
    description: string;
    users: ChatUser[];
    roles: Role[];
    maxUsersAmount: number;
    creatorId: string;
    creator: MessengerUser;
}

export class ChatUser implements IChatUser {
    user!: MessengerUser;
    id!: string;
    chat!: Chat;
    chatId!: string;
    role!: Role;

    constructor(data?: IChatUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.user = _data["user"] ? MessengerUser.fromJS(_data["user"], _mappings) : <any>undefined;
            this.id = _data["id"];
            this.chat = _data["chat"] ? Chat.fromJS(_data["chat"], _mappings) : <any>undefined;
            this.chatId = _data["chatId"];
            this.role = _data["role"] ? Role.fromJS(_data["role"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): ChatUser | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ChatUser>(data, _mappings, ChatUser);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["chat"] = this.chat ? this.chat.toJSON() : <any>undefined;
        data["chatId"] = this.chatId;
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        return data;
    }
}

export interface IChatUser {
    user: MessengerUser;
    id: string;
    chat: Chat;
    chatId: string;
    role: Role;
}

export class Role implements IRole {
    id!: string;
    chat!: Chat;
    name!: string;
    canEditMessages!: ActionOption;
    canDeleteMessages!: ActionOption;
    canWriteMessages!: ActionOption;
    canReadMessages!: ActionOption;
    canAddUsers!: ActionOption;
    canDeleteUsers!: ActionOption;
    canPinMessages!: ActionOption;
    canSeeChannelMembers!: ActionOption;
    canInviteOtherUsers!: ActionOption;
    canEditChannelDescription!: ActionOption;
    canDeleteChat!: ActionOption;

    constructor(data?: IRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.chat = _data["chat"] ? Chat.fromJS(_data["chat"], _mappings) : <any>undefined;
            this.name = _data["name"];
            this.canEditMessages = _data["canEditMessages"];
            this.canDeleteMessages = _data["canDeleteMessages"];
            this.canWriteMessages = _data["canWriteMessages"];
            this.canReadMessages = _data["canReadMessages"];
            this.canAddUsers = _data["canAddUsers"];
            this.canDeleteUsers = _data["canDeleteUsers"];
            this.canPinMessages = _data["canPinMessages"];
            this.canSeeChannelMembers = _data["canSeeChannelMembers"];
            this.canInviteOtherUsers = _data["canInviteOtherUsers"];
            this.canEditChannelDescription = _data["canEditChannelDescription"];
            this.canDeleteChat = _data["canDeleteChat"];
        }
    }

    static fromJS(data: any, _mappings?: any): Role | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Role>(data, _mappings, Role);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["chat"] = this.chat ? this.chat.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["canEditMessages"] = this.canEditMessages;
        data["canDeleteMessages"] = this.canDeleteMessages;
        data["canWriteMessages"] = this.canWriteMessages;
        data["canReadMessages"] = this.canReadMessages;
        data["canAddUsers"] = this.canAddUsers;
        data["canDeleteUsers"] = this.canDeleteUsers;
        data["canPinMessages"] = this.canPinMessages;
        data["canSeeChannelMembers"] = this.canSeeChannelMembers;
        data["canInviteOtherUsers"] = this.canInviteOtherUsers;
        data["canEditChannelDescription"] = this.canEditChannelDescription;
        data["canDeleteChat"] = this.canDeleteChat;
        return data;
    }
}

export interface IRole {
    id: string;
    chat: Chat;
    name: string;
    canEditMessages: ActionOption;
    canDeleteMessages: ActionOption;
    canWriteMessages: ActionOption;
    canReadMessages: ActionOption;
    canAddUsers: ActionOption;
    canDeleteUsers: ActionOption;
    canPinMessages: ActionOption;
    canSeeChannelMembers: ActionOption;
    canInviteOtherUsers: ActionOption;
    canEditChannelDescription: ActionOption;
    canDeleteChat: ActionOption;
}

export enum ActionOption {
    Unavailable = 0,
    Enabled = 1,
    Disabled = 2,
}

function jsonParse(json: any, reviver?: any) {
    json = JSON.parse(json, reviver);

    var byid: any = {};
    var refs: any = [];
    json = (function recurse(obj: any, prop?: any, parent?: any) {
        if (typeof obj !== 'object' || !obj)
            return obj;
        
        if ("$ref" in obj) {
            let ref = obj.$ref;
            if (ref in byid)
                return byid[ref];
            refs.push([parent, prop, ref]);
            return undefined;
        } else if ("$id" in obj) {
            let id = obj.$id;
            delete obj.$id;
            if ("$values" in obj)
                obj = obj.$values;
            byid[id] = obj;
        }
        
        if (Array.isArray(obj)) {
            obj = obj.map((v, i) => recurse(v, i, obj));
        } else {
            for (var p in obj) {
                if (obj.hasOwnProperty(p) && obj[p] && typeof obj[p] === 'object')
                    obj[p] = recurse(obj[p], p, obj);
            }
        }

        return obj;
    })(json);

    for (let i = 0; i < refs.length; i++) {
        const ref = refs[i];
        ref[0][ref[1]] = byid[ref[2]];
    }

    return json;
}

function createInstance<T>(data: any, mappings: any, type: any): T | null {
  if (!mappings)
    mappings = [];
  if (!data)
    return null;

  const mappingIndexName = "__mappingIndex";
  if (data[mappingIndexName])
    return <T>mappings[data[mappingIndexName]].target;

  data[mappingIndexName] = mappings.length;

  let result: any = new type();
  mappings.push({ source: data, target: result });
  result.init(data, mappings);
  return result;
}

export class Do_Svyazi_User_ApiClient_Exception extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isDo_Svyazi_User_ApiClient_Exception = true;

    static isDo_Svyazi_User_ApiClient_Exception(obj: any): obj is Do_Svyazi_User_ApiClient_Exception {
        return obj.isDo_Svyazi_User_ApiClient_Exception === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new Do_Svyazi_User_ApiClient_Exception(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}