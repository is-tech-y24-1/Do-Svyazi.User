//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.0.0 (NJsonSchema v10.7.1.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

import * as moment from 'moment';

export interface IAuthenticateClient {
    login(model: Login): Promise<FileResponse>;
    register(model: Register): Promise<FileResponse>;
    registerAdmin(model: RegisterAdmin): Promise<FileResponse>;
}

export class AuthenticateClient implements IAuthenticateClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    login(model: Login , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Authenticate/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    register(model: Register , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Authenticate/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRegister(_response);
        });
    }

    protected processRegister(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    registerAdmin(model: RegisterAdmin , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Authenticate/register-admin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRegisterAdmin(_response);
        });
    }

    protected processRegisterAdmin(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export interface IChatClient {
    getChats(): Promise<MessengerChatDto[]>;
    getChatById(chatId: string): Promise<MessengerChatDto>;
    getUserIdsByChatId(chatId: string): Promise<string[]>;
    getUsersByChatId(chatId: string): Promise<ChatUser[]>;
    addChannel(addChannelCommand: AddChannel): Promise<void>;
    addGroupChat(addGroupChatCommand: AddGroupChat): Promise<void>;
    addPersonalChat(addPersonalChatCommand: AddPersonalChat): Promise<void>;
    addSavedMessages(addSavedMessagesCommand: AddSavedMessages): Promise<void>;
    addUserToChat(addUserToChatCommand: AddUserToChat): Promise<void>;
    deleteUserFromChat(deleteUserFromChatCommand: DeleteUserFromChat): Promise<void>;
}

export class ChatClient implements IChatClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    getChats(  cancelToken?: CancelToken | undefined): Promise<MessengerChatDto[]> {
        let url_ = this.baseUrl + "/api/Chat/GetChats";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetChats(_response);
        });
    }

    protected processGetChats(response: AxiosResponse): Promise<MessengerChatDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MessengerChatDto.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<MessengerChatDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MessengerChatDto[]>(null as any);
    }

    getChatById(chatId: string , cancelToken?: CancelToken | undefined): Promise<MessengerChatDto> {
        let url_ = this.baseUrl + "/api/Chat/GetChatById?";
        if (chatId === undefined || chatId === null)
            throw new Error("The parameter 'chatId' must be defined and cannot be null.");
        else
            url_ += "chatId=" + encodeURIComponent("" + chatId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetChatById(_response);
        });
    }

    protected processGetChatById(response: AxiosResponse): Promise<MessengerChatDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MessengerChatDto.fromJS(resultData200, _mappings);
            return Promise.resolve<MessengerChatDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MessengerChatDto>(null as any);
    }

    getUserIdsByChatId(chatId: string , cancelToken?: CancelToken | undefined): Promise<string[]> {
        let url_ = this.baseUrl + "/api/Chat/GetUserIdsByChatId?";
        if (chatId === undefined || chatId === null)
            throw new Error("The parameter 'chatId' must be defined and cannot be null.");
        else
            url_ += "chatId=" + encodeURIComponent("" + chatId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetUserIdsByChatId(_response);
        });
    }

    protected processGetUserIdsByChatId(response: AxiosResponse): Promise<string[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<string[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string[]>(null as any);
    }

    getUsersByChatId(chatId: string , cancelToken?: CancelToken | undefined): Promise<ChatUser[]> {
        let url_ = this.baseUrl + "/api/Chat/GetUsersByChatId?";
        if (chatId === undefined || chatId === null)
            throw new Error("The parameter 'chatId' must be defined and cannot be null.");
        else
            url_ += "chatId=" + encodeURIComponent("" + chatId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetUsersByChatId(_response);
        });
    }

    protected processGetUsersByChatId(response: AxiosResponse): Promise<ChatUser[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ChatUser.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ChatUser[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ChatUser[]>(null as any);
    }

    addChannel(addChannelCommand: AddChannel , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Chat/AddChannel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(addChannelCommand);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddChannel(_response);
        });
    }

    protected processAddChannel(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    addGroupChat(addGroupChatCommand: AddGroupChat , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Chat/AddGroupChat";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(addGroupChatCommand);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddGroupChat(_response);
        });
    }

    protected processAddGroupChat(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    addPersonalChat(addPersonalChatCommand: AddPersonalChat , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Chat/AddPersonalChat";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(addPersonalChatCommand);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddPersonalChat(_response);
        });
    }

    protected processAddPersonalChat(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    addSavedMessages(addSavedMessagesCommand: AddSavedMessages , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Chat/AddSavedMessages";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(addSavedMessagesCommand);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddSavedMessages(_response);
        });
    }

    protected processAddSavedMessages(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    addUserToChat(addUserToChatCommand: AddUserToChat , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Chat/AddUserToChat";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(addUserToChatCommand);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddUserToChat(_response);
        });
    }

    protected processAddUserToChat(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    deleteUserFromChat(deleteUserFromChatCommand: DeleteUserFromChat , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Chat/DeleteUserFromChat";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(deleteUserFromChatCommand);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "DELETE",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteUserFromChat(_response);
        });
    }

    protected processDeleteUserFromChat(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export interface IRolesClient {
    getRoleByUserId(userId: string, chatId: string): Promise<RoleDto>;
    createRoleForChat(createRoleForChat: CreateRoleForChat): Promise<void>;
    changeRoleForUserById(changeRoleForUserById: ChangeRoleForUserById): Promise<void>;
}

export class RolesClient implements IRolesClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    getRoleByUserId(userId: string, chatId: string , cancelToken?: CancelToken | undefined): Promise<RoleDto> {
        let url_ = this.baseUrl + "/api/Roles/GetRoleByUserId?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (chatId === undefined || chatId === null)
            throw new Error("The parameter 'chatId' must be defined and cannot be null.");
        else
            url_ += "chatId=" + encodeURIComponent("" + chatId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRoleByUserId(_response);
        });
    }

    protected processGetRoleByUserId(response: AxiosResponse): Promise<RoleDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RoleDto.fromJS(resultData200, _mappings);
            return Promise.resolve<RoleDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RoleDto>(null as any);
    }

    createRoleForChat(createRoleForChat: CreateRoleForChat , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Roles/CreateRoleForChat";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createRoleForChat);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateRoleForChat(_response);
        });
    }

    protected processCreateRoleForChat(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    changeRoleForUserById(changeRoleForUserById: ChangeRoleForUserById , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Roles/ChangeRoleForUserById";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(changeRoleForUserById);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeRoleForUserById(_response);
        });
    }

    protected processChangeRoleForUserById(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export interface IUserClient {
    getAll(): Promise<MessengerUserDto[]>;
    getUser(userId: string): Promise<MessengerUser>;
    getAllChatsByUserId(userId: string): Promise<MessengerChatDto[]>;
    getAllChatsIdsByUserId(userId: string): Promise<string[]>;
    setNickNameById(setUserNickNameById: SetUserNickNameById): Promise<void>;
    deleteUser(deleteUser: DeleteUser): Promise<void>;
    addUser(addUser: AddUser): Promise<string>;
    changeDescription(changeUserDescriptionById: ChangeUserDescriptionById): Promise<void>;
    changeName(changeUserNameById: ChangeUserNameById): Promise<void>;
}

export class UserClient implements IUserClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    getAll(  cancelToken?: CancelToken | undefined): Promise<MessengerUserDto[]> {
        let url_ = this.baseUrl + "/api/User/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<MessengerUserDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MessengerUserDto.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<MessengerUserDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MessengerUserDto[]>(null as any);
    }

    getUser(userId: string , cancelToken?: CancelToken | undefined): Promise<MessengerUser> {
        let url_ = this.baseUrl + "/api/User/GetUser?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetUser(_response);
        });
    }

    protected processGetUser(response: AxiosResponse): Promise<MessengerUser> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MessengerUser.fromJS(resultData200, _mappings);
            return Promise.resolve<MessengerUser>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MessengerUser>(null as any);
    }

    getAllChatsByUserId(userId: string , cancelToken?: CancelToken | undefined): Promise<MessengerChatDto[]> {
        let url_ = this.baseUrl + "/api/User/GetAllChatsByUserId?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllChatsByUserId(_response);
        });
    }

    protected processGetAllChatsByUserId(response: AxiosResponse): Promise<MessengerChatDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MessengerChatDto.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<MessengerChatDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MessengerChatDto[]>(null as any);
    }

    getAllChatsIdsByUserId(userId: string , cancelToken?: CancelToken | undefined): Promise<string[]> {
        let url_ = this.baseUrl + "/api/User/GetAllChatsIdsByUserId?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllChatsIdsByUserId(_response);
        });
    }

    protected processGetAllChatsIdsByUserId(response: AxiosResponse): Promise<string[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<string[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string[]>(null as any);
    }

    setNickNameById(setUserNickNameById: SetUserNickNameById , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/User/SetNickNameById";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(setUserNickNameById);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSetNickNameById(_response);
        });
    }

    protected processSetNickNameById(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    deleteUser(deleteUser: DeleteUser , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/User/DeleteUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(deleteUser);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteUser(_response);
        });
    }

    protected processDeleteUser(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    addUser(addUser: AddUser , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/User/AddUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(addUser);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddUser(_response);
        });
    }

    protected processAddUser(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    changeDescription(changeUserDescriptionById: ChangeUserDescriptionById , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/User/ChangeDescription";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(changeUserDescriptionById);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeDescription(_response);
        });
    }

    protected processChangeDescription(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    changeName(changeUserNameById: ChangeUserNameById , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/User/ChangeName";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(changeUserNameById);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeName(_response);
        });
    }

    protected processChangeName(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class Login implements ILogin {
    model!: LoginModel;

    constructor(data?: ILogin) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.model = _data["model"] ? LoginModel.fromJS(_data["model"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): Login | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Login>(data, _mappings, Login);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["model"] = this.model ? this.model.toJSON() : <any>undefined;
        return data;
    }
}

export interface ILogin {
    model: LoginModel;
}

export class LoginModel implements ILoginModel {
    id!: string;
    nickName!: string;
    password!: string;

    constructor(data?: ILoginModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.nickName = _data["nickName"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any, _mappings?: any): LoginModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<LoginModel>(data, _mappings, LoginModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["nickName"] = this.nickName;
        data["password"] = this.password;
        return data;
    }
}

export interface ILoginModel {
    id: string;
    nickName: string;
    password: string;
}

export class Register implements IRegister {
    model!: RegisterModel;

    constructor(data?: IRegister) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.model = _data["model"] ? RegisterModel.fromJS(_data["model"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): Register | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Register>(data, _mappings, Register);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["model"] = this.model ? this.model.toJSON() : <any>undefined;
        return data;
    }
}

export interface IRegister {
    model: RegisterModel;
}

export class RegisterModel implements IRegisterModel {
    name!: string;
    nickName!: string;
    email!: string;
    password!: string;

    constructor(data?: IRegisterModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.name = _data["name"];
            this.nickName = _data["nickName"];
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any, _mappings?: any): RegisterModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<RegisterModel>(data, _mappings, RegisterModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["nickName"] = this.nickName;
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface IRegisterModel {
    name: string;
    nickName: string;
    email: string;
    password: string;
}

export class RegisterAdmin implements IRegisterAdmin {
    model!: RegisterModel;

    constructor(data?: IRegisterAdmin) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.model = _data["model"] ? RegisterModel.fromJS(_data["model"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): RegisterAdmin | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<RegisterAdmin>(data, _mappings, RegisterAdmin);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["model"] = this.model ? this.model.toJSON() : <any>undefined;
        return data;
    }
}

export interface IRegisterAdmin {
    model: RegisterModel;
}

export class MessengerChatDto implements IMessengerChatDto {
    id!: string;
    name!: string | undefined;
    description!: string | undefined;
    creator!: MessengerUserDto | undefined;
    users!: string[];
    roles!: RoleDto[];

    constructor(data?: IMessengerChatDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.creator = _data["creator"] ? MessengerUserDto.fromJS(_data["creator"], _mappings) : <any>undefined;
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(item);
            }
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(RoleDto.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): MessengerChatDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<MessengerChatDto>(data, _mappings, MessengerChatDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["creator"] = this.creator ? this.creator.toJSON() : <any>undefined;
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item);
        }
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        return data;
    }
}

export interface IMessengerChatDto {
    id: string;
    name: string | undefined;
    description: string | undefined;
    creator: MessengerUserDto | undefined;
    users: string[];
    roles: RoleDto[];
}

export class MessengerUserDto implements IMessengerUserDto {
    id!: string;
    name!: string | undefined;
    nickName!: string | undefined;
    description!: string | undefined;

    constructor(data?: IMessengerUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.nickName = _data["nickName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any, _mappings?: any): MessengerUserDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<MessengerUserDto>(data, _mappings, MessengerUserDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["nickName"] = this.nickName;
        data["description"] = this.description;
        return data;
    }
}

export interface IMessengerUserDto {
    id: string;
    name: string | undefined;
    nickName: string | undefined;
    description: string | undefined;
}

export class RoleDto implements IRoleDto {
    name!: string;
    canEditMessages!: ActionOption;
    canDeleteMessages!: ActionOption;
    canWriteMessages!: ActionOption;
    canReadMessages!: ActionOption;
    canAddUsers!: ActionOption;
    canDeleteUsers!: ActionOption;
    canPinMessages!: ActionOption;
    canSeeChannelMembers!: ActionOption;
    canInviteOtherUsers!: ActionOption;
    canEditChannelDescription!: ActionOption;
    canDeleteChat!: ActionOption;

    constructor(data?: IRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.name = _data["name"];
            this.canEditMessages = _data["canEditMessages"];
            this.canDeleteMessages = _data["canDeleteMessages"];
            this.canWriteMessages = _data["canWriteMessages"];
            this.canReadMessages = _data["canReadMessages"];
            this.canAddUsers = _data["canAddUsers"];
            this.canDeleteUsers = _data["canDeleteUsers"];
            this.canPinMessages = _data["canPinMessages"];
            this.canSeeChannelMembers = _data["canSeeChannelMembers"];
            this.canInviteOtherUsers = _data["canInviteOtherUsers"];
            this.canEditChannelDescription = _data["canEditChannelDescription"];
            this.canDeleteChat = _data["canDeleteChat"];
        }
    }

    static fromJS(data: any, _mappings?: any): RoleDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<RoleDto>(data, _mappings, RoleDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["canEditMessages"] = this.canEditMessages;
        data["canDeleteMessages"] = this.canDeleteMessages;
        data["canWriteMessages"] = this.canWriteMessages;
        data["canReadMessages"] = this.canReadMessages;
        data["canAddUsers"] = this.canAddUsers;
        data["canDeleteUsers"] = this.canDeleteUsers;
        data["canPinMessages"] = this.canPinMessages;
        data["canSeeChannelMembers"] = this.canSeeChannelMembers;
        data["canInviteOtherUsers"] = this.canInviteOtherUsers;
        data["canEditChannelDescription"] = this.canEditChannelDescription;
        data["canDeleteChat"] = this.canDeleteChat;
        return data;
    }
}

export interface IRoleDto {
    name: string;
    canEditMessages: ActionOption;
    canDeleteMessages: ActionOption;
    canWriteMessages: ActionOption;
    canReadMessages: ActionOption;
    canAddUsers: ActionOption;
    canDeleteUsers: ActionOption;
    canPinMessages: ActionOption;
    canSeeChannelMembers: ActionOption;
    canInviteOtherUsers: ActionOption;
    canEditChannelDescription: ActionOption;
    canDeleteChat: ActionOption;
}

export enum ActionOption {
    Unavailable = 0,
    Enabled = 1,
    Disabled = 2,
}

export class ChatUser implements IChatUser {
    user!: MessengerUser;
    id!: string;
    messengerUserId!: string;
    chat!: Chat;
    chatId!: string;
    role!: Role;

    constructor(data?: IChatUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.user = _data["user"] ? MessengerUser.fromJS(_data["user"], _mappings) : <any>undefined;
            this.id = _data["id"];
            this.messengerUserId = _data["messengerUserId"];
            this.chat = _data["chat"] ? Chat.fromJS(_data["chat"], _mappings) : <any>undefined;
            this.chatId = _data["chatId"];
            this.role = _data["role"] ? Role.fromJS(_data["role"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): ChatUser | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ChatUser>(data, _mappings, ChatUser);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["messengerUserId"] = this.messengerUserId;
        data["chat"] = this.chat ? this.chat.toJSON() : <any>undefined;
        data["chatId"] = this.chatId;
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        return data;
    }
}

export interface IChatUser {
    user: MessengerUser;
    id: string;
    messengerUserId: string;
    chat: Chat;
    chatId: string;
    role: Role;
}

export class MessengerUser implements IMessengerUser {
    id!: string;
    name!: string;
    nickName!: string;
    description!: string;
    chats!: Chat[];

    constructor(data?: IMessengerUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.nickName = _data["nickName"];
            this.description = _data["description"];
            if (Array.isArray(_data["chats"])) {
                this.chats = [] as any;
                for (let item of _data["chats"])
                    this.chats!.push(Chat.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): MessengerUser | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<MessengerUser>(data, _mappings, MessengerUser);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["nickName"] = this.nickName;
        data["description"] = this.description;
        if (Array.isArray(this.chats)) {
            data["chats"] = [];
            for (let item of this.chats)
                data["chats"].push(item.toJSON());
        }
        return data;
    }
}

export interface IMessengerUser {
    id: string;
    name: string;
    nickName: string;
    description: string;
    chats: Chat[];
}

export abstract class Chat implements IChat {
    id!: string;
    name!: string;
    description!: string;
    creator!: MessengerUser;
    creatorId!: string;
    maxUsersAmount!: number;
    users!: ChatUser[];
    roles!: Role[];

    constructor(data?: IChat) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.creator = _data["creator"] ? MessengerUser.fromJS(_data["creator"], _mappings) : <any>undefined;
            this.creatorId = _data["creatorId"];
            this.maxUsersAmount = _data["maxUsersAmount"];
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(ChatUser.fromJS(item, _mappings));
            }
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(Role.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): Chat | null {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'Chat' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["creator"] = this.creator ? this.creator.toJSON() : <any>undefined;
        data["creatorId"] = this.creatorId;
        data["maxUsersAmount"] = this.maxUsersAmount;
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        return data;
    }
}

export interface IChat {
    id: string;
    name: string;
    description: string;
    creator: MessengerUser;
    creatorId: string;
    maxUsersAmount: number;
    users: ChatUser[];
    roles: Role[];
}

export class Role implements IRole {
    id!: string;
    chat!: Chat;
    name!: string;
    canEditMessages!: ActionOption;
    canDeleteMessages!: ActionOption;
    canWriteMessages!: ActionOption;
    canReadMessages!: ActionOption;
    canAddUsers!: ActionOption;
    canDeleteUsers!: ActionOption;
    canPinMessages!: ActionOption;
    canSeeChannelMembers!: ActionOption;
    canInviteOtherUsers!: ActionOption;
    canEditChannelDescription!: ActionOption;
    canDeleteChat!: ActionOption;

    constructor(data?: IRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.chat = _data["chat"] ? Chat.fromJS(_data["chat"], _mappings) : <any>undefined;
            this.name = _data["name"];
            this.canEditMessages = _data["canEditMessages"];
            this.canDeleteMessages = _data["canDeleteMessages"];
            this.canWriteMessages = _data["canWriteMessages"];
            this.canReadMessages = _data["canReadMessages"];
            this.canAddUsers = _data["canAddUsers"];
            this.canDeleteUsers = _data["canDeleteUsers"];
            this.canPinMessages = _data["canPinMessages"];
            this.canSeeChannelMembers = _data["canSeeChannelMembers"];
            this.canInviteOtherUsers = _data["canInviteOtherUsers"];
            this.canEditChannelDescription = _data["canEditChannelDescription"];
            this.canDeleteChat = _data["canDeleteChat"];
        }
    }

    static fromJS(data: any, _mappings?: any): Role | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Role>(data, _mappings, Role);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["chat"] = this.chat ? this.chat.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["canEditMessages"] = this.canEditMessages;
        data["canDeleteMessages"] = this.canDeleteMessages;
        data["canWriteMessages"] = this.canWriteMessages;
        data["canReadMessages"] = this.canReadMessages;
        data["canAddUsers"] = this.canAddUsers;
        data["canDeleteUsers"] = this.canDeleteUsers;
        data["canPinMessages"] = this.canPinMessages;
        data["canSeeChannelMembers"] = this.canSeeChannelMembers;
        data["canInviteOtherUsers"] = this.canInviteOtherUsers;
        data["canEditChannelDescription"] = this.canEditChannelDescription;
        data["canDeleteChat"] = this.canDeleteChat;
        return data;
    }
}

export interface IRole {
    id: string;
    chat: Chat;
    name: string;
    canEditMessages: ActionOption;
    canDeleteMessages: ActionOption;
    canWriteMessages: ActionOption;
    canReadMessages: ActionOption;
    canAddUsers: ActionOption;
    canDeleteUsers: ActionOption;
    canPinMessages: ActionOption;
    canSeeChannelMembers: ActionOption;
    canInviteOtherUsers: ActionOption;
    canEditChannelDescription: ActionOption;
    canDeleteChat: ActionOption;
}

export class AddChannel implements IAddChannel {
    adminId!: string;
    name!: string;
    description!: string;

    constructor(data?: IAddChannel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.adminId = _data["adminId"];
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any, _mappings?: any): AddChannel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<AddChannel>(data, _mappings, AddChannel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adminId"] = this.adminId;
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }
}

export interface IAddChannel {
    adminId: string;
    name: string;
    description: string;
}

export class AddGroupChat implements IAddGroupChat {
    adminId!: string;
    name!: string;
    description!: string;

    constructor(data?: IAddGroupChat) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.adminId = _data["adminId"];
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any, _mappings?: any): AddGroupChat | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<AddGroupChat>(data, _mappings, AddGroupChat);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adminId"] = this.adminId;
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }
}

export interface IAddGroupChat {
    adminId: string;
    name: string;
    description: string;
}

export class AddPersonalChat implements IAddPersonalChat {
    firstUserId!: string;
    secondUserId!: string;
    name!: string;
    description!: string;

    constructor(data?: IAddPersonalChat) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.firstUserId = _data["firstUserId"];
            this.secondUserId = _data["secondUserId"];
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any, _mappings?: any): AddPersonalChat | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<AddPersonalChat>(data, _mappings, AddPersonalChat);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstUserId"] = this.firstUserId;
        data["secondUserId"] = this.secondUserId;
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }
}

export interface IAddPersonalChat {
    firstUserId: string;
    secondUserId: string;
    name: string;
    description: string;
}

export class AddSavedMessages implements IAddSavedMessages {
    userId!: string;
    name!: string;
    description!: string;

    constructor(data?: IAddSavedMessages) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any, _mappings?: any): AddSavedMessages | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<AddSavedMessages>(data, _mappings, AddSavedMessages);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }
}

export interface IAddSavedMessages {
    userId: string;
    name: string;
    description: string;
}

export class AddUserToChat implements IAddUserToChat {
    userId!: string;
    chatId!: string;

    constructor(data?: IAddUserToChat) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.chatId = _data["chatId"];
        }
    }

    static fromJS(data: any, _mappings?: any): AddUserToChat | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<AddUserToChat>(data, _mappings, AddUserToChat);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["chatId"] = this.chatId;
        return data;
    }
}

export interface IAddUserToChat {
    userId: string;
    chatId: string;
}

export class DeleteUserFromChat implements IDeleteUserFromChat {
    userId!: string;
    chatId!: string;

    constructor(data?: IDeleteUserFromChat) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.chatId = _data["chatId"];
        }
    }

    static fromJS(data: any, _mappings?: any): DeleteUserFromChat | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<DeleteUserFromChat>(data, _mappings, DeleteUserFromChat);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["chatId"] = this.chatId;
        return data;
    }
}

export interface IDeleteUserFromChat {
    userId: string;
    chatId: string;
}

export class CreateRoleForChat implements ICreateRoleForChat {
    role!: RoleDto;
    chatId!: string;

    constructor(data?: ICreateRoleForChat) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.role = _data["role"] ? RoleDto.fromJS(_data["role"], _mappings) : <any>undefined;
            this.chatId = _data["chatId"];
        }
    }

    static fromJS(data: any, _mappings?: any): CreateRoleForChat | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CreateRoleForChat>(data, _mappings, CreateRoleForChat);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        data["chatId"] = this.chatId;
        return data;
    }
}

export interface ICreateRoleForChat {
    role: RoleDto;
    chatId: string;
}

export class ChangeRoleForUserById implements IChangeRoleForUserById {
    userId!: string;
    chatId!: string;
    role!: RoleDto;

    constructor(data?: IChangeRoleForUserById) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.chatId = _data["chatId"];
            this.role = _data["role"] ? RoleDto.fromJS(_data["role"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): ChangeRoleForUserById | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ChangeRoleForUserById>(data, _mappings, ChangeRoleForUserById);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["chatId"] = this.chatId;
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        return data;
    }
}

export interface IChangeRoleForUserById {
    userId: string;
    chatId: string;
    role: RoleDto;
}

export class SetUserNickNameById implements ISetUserNickNameById {
    userId!: string;
    nickName!: string;

    constructor(data?: ISetUserNickNameById) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.nickName = _data["nickName"];
        }
    }

    static fromJS(data: any, _mappings?: any): SetUserNickNameById | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<SetUserNickNameById>(data, _mappings, SetUserNickNameById);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["nickName"] = this.nickName;
        return data;
    }
}

export interface ISetUserNickNameById {
    userId: string;
    nickName: string;
}

export class DeleteUser implements IDeleteUser {
    userId!: string;

    constructor(data?: IDeleteUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any, _mappings?: any): DeleteUser | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<DeleteUser>(data, _mappings, DeleteUser);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        return data;
    }
}

export interface IDeleteUser {
    userId: string;
}

export class AddUser implements IAddUser {
    name!: string;
    nickName!: string;
    description!: string;

    constructor(data?: IAddUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.name = _data["name"];
            this.nickName = _data["nickName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any, _mappings?: any): AddUser | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<AddUser>(data, _mappings, AddUser);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["nickName"] = this.nickName;
        data["description"] = this.description;
        return data;
    }
}

export interface IAddUser {
    name: string;
    nickName: string;
    description: string;
}

export class ChangeUserDescriptionById implements IChangeUserDescriptionById {
    userId!: string;
    description!: string;

    constructor(data?: IChangeUserDescriptionById) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any, _mappings?: any): ChangeUserDescriptionById | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ChangeUserDescriptionById>(data, _mappings, ChangeUserDescriptionById);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["description"] = this.description;
        return data;
    }
}

export interface IChangeUserDescriptionById {
    userId: string;
    description: string;
}

export class ChangeUserNameById implements IChangeUserNameById {
    userId!: string;
    name!: string;

    constructor(data?: IChangeUserNameById) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any, _mappings?: any): ChangeUserNameById | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ChangeUserNameById>(data, _mappings, ChangeUserNameById);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["name"] = this.name;
        return data;
    }
}

export interface IChangeUserNameById {
    userId: string;
    name: string;
}

function jsonParse(json: any, reviver?: any) {
    json = JSON.parse(json, reviver);

    var byid: any = {};
    var refs: any = [];
    json = (function recurse(obj: any, prop?: any, parent?: any) {
        if (typeof obj !== 'object' || !obj)
            return obj;
        
        if ("$ref" in obj) {
            let ref = obj.$ref;
            if (ref in byid)
                return byid[ref];
            refs.push([parent, prop, ref]);
            return undefined;
        } else if ("$id" in obj) {
            let id = obj.$id;
            delete obj.$id;
            if ("$values" in obj)
                obj = obj.$values;
            byid[id] = obj;
        }
        
        if (Array.isArray(obj)) {
            obj = obj.map((v, i) => recurse(v, i, obj));
        } else {
            for (var p in obj) {
                if (obj.hasOwnProperty(p) && obj[p] && typeof obj[p] === 'object')
                    obj[p] = recurse(obj[p], p, obj);
            }
        }

        return obj;
    })(json);

    for (let i = 0; i < refs.length; i++) {
        const ref = refs[i];
        ref[0][ref[1]] = byid[ref[2]];
    }

    return json;
}

function createInstance<T>(data: any, mappings: any, type: any): T | null {
  if (!mappings)
    mappings = [];
  if (!data)
    return null;

  const mappingIndexName = "__mappingIndex";
  if (data[mappingIndexName])
    return <T>mappings[data[mappingIndexName]].target;

  data[mappingIndexName] = mappings.length;

  let result: any = new type();
  mappings.push({ source: data, target: result });
  result.init(data, mappings);
  return result;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class Do_Svyazi_User_ApiClient_Exception extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isDo_Svyazi_User_ApiClient_Exception = true;

    static isDo_Svyazi_User_ApiClient_Exception(obj: any): obj is Do_Svyazi_User_ApiClient_Exception {
        return obj.isDo_Svyazi_User_ApiClient_Exception === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new Do_Svyazi_User_ApiClient_Exception(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}