//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.0.0 (NJsonSchema v10.7.1.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

import * as moment from 'moment';

export interface IAuthenticateClient {
    getAll(): Promise<MessengerUser[]>;
    login(model: LoginRequest): Promise<void>;
    register(model: RegisterCommand): Promise<void>;
    authenticateByJwt(jwtToken: string | null): Promise<AuthenticateResponse>;
    registerAdmin(model: RegisterAdminCommand): Promise<void>;
}

export class AuthenticateClient implements IAuthenticateClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    getAll(  cancelToken?: CancelToken | undefined): Promise<MessengerUser[]> {
        let url_ = this.baseUrl + "/api/Authenticate/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<MessengerUser[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MessengerUser.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<MessengerUser[]>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MessengerUser[]>(null as any);
    }

    login(model: LoginRequest , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Authenticate/Login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    register(model: RegisterCommand , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Authenticate/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRegister(_response);
        });
    }

    protected processRegister(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);

        } else if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    authenticateByJwt(jwtToken: string | null , cancelToken?: CancelToken | undefined): Promise<AuthenticateResponse> {
        let url_ = this.baseUrl + "/api/Authenticate/AuthenticateByJwt";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "jwtToken": jwtToken !== undefined && jwtToken !== null ? "" + jwtToken : "",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAuthenticateByJwt(_response);
        });
    }

    protected processAuthenticateByJwt(response: AxiosResponse): Promise<AuthenticateResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AuthenticateResponse.fromJS(resultData200, _mappings);
            return Promise.resolve<AuthenticateResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AuthenticateResponse>(null as any);
    }

    registerAdmin(model: RegisterAdminCommand , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Authenticate/RegisterAdmin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRegisterAdmin(_response);
        });
    }

    protected processRegisterAdmin(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);

        } else if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export interface IChatClient {
    getChats(): Promise<MessengerChatDto[]>;
    getChatById(chatId: string): Promise<MessengerChatDto>;
    getUserIdsByChatId(chatId: string): Promise<string[]>;
    getUsersByChatId(chatId: string): Promise<ChatUserDto[]>;
    addChannel(addChannelCommand: AddChannelCommand): Promise<void>;
    addGroupChat(addGroupChatCommand: AddGroupChatCommand): Promise<void>;
    addPersonalChat(addPersonalChatCommand: AddPersonalChatCommand): Promise<void>;
    addSavedMessages(addSavedMessagesCommand: AddSavedMessagesCommand): Promise<void>;
    addUserToChat(addUserToChatCommand: AddUserToChatCommand): Promise<void>;
    deleteUserFromChat(deleteUserFromChatCommand: DeleteUserFromChatCommand): Promise<void>;
}

export class ChatClient implements IChatClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    getChats(  cancelToken?: CancelToken | undefined): Promise<MessengerChatDto[]> {
        let url_ = this.baseUrl + "/api/Chat/GetChats";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetChats(_response);
        });
    }

    protected processGetChats(response: AxiosResponse): Promise<MessengerChatDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MessengerChatDto.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<MessengerChatDto[]>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MessengerChatDto[]>(null as any);
    }

    getChatById(chatId: string , cancelToken?: CancelToken | undefined): Promise<MessengerChatDto> {
        let url_ = this.baseUrl + "/api/Chat/GetChatById?";
        if (chatId === undefined || chatId === null)
            throw new Error("The parameter 'chatId' must be defined and cannot be null.");
        else
            url_ += "chatId=" + encodeURIComponent("" + chatId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetChatById(_response);
        });
    }

    protected processGetChatById(response: AxiosResponse): Promise<MessengerChatDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MessengerChatDto.fromJS(resultData200, _mappings);
            return Promise.resolve<MessengerChatDto>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MessengerChatDto>(null as any);
    }

    getUserIdsByChatId(chatId: string , cancelToken?: CancelToken | undefined): Promise<string[]> {
        let url_ = this.baseUrl + "/api/Chat/GetUserIdsByChatId?";
        if (chatId === undefined || chatId === null)
            throw new Error("The parameter 'chatId' must be defined and cannot be null.");
        else
            url_ += "chatId=" + encodeURIComponent("" + chatId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetUserIdsByChatId(_response);
        });
    }

    protected processGetUserIdsByChatId(response: AxiosResponse): Promise<string[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<string[]>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string[]>(null as any);
    }

    getUsersByChatId(chatId: string , cancelToken?: CancelToken | undefined): Promise<ChatUserDto[]> {
        let url_ = this.baseUrl + "/api/Chat/GetUsersByChatId?";
        if (chatId === undefined || chatId === null)
            throw new Error("The parameter 'chatId' must be defined and cannot be null.");
        else
            url_ += "chatId=" + encodeURIComponent("" + chatId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetUsersByChatId(_response);
        });
    }

    protected processGetUsersByChatId(response: AxiosResponse): Promise<ChatUserDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ChatUserDto.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ChatUserDto[]>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ChatUserDto[]>(null as any);
    }

    addChannel(addChannelCommand: AddChannelCommand , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Chat/AddChannel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(addChannelCommand);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddChannel(_response);
        });
    }

    protected processAddChannel(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);

        } else if (status === 201) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    addGroupChat(addGroupChatCommand: AddGroupChatCommand , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Chat/AddGroupChat";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(addGroupChatCommand);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddGroupChat(_response);
        });
    }

    protected processAddGroupChat(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);

        } else if (status === 201) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    addPersonalChat(addPersonalChatCommand: AddPersonalChatCommand , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Chat/AddPersonalChat";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(addPersonalChatCommand);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddPersonalChat(_response);
        });
    }

    protected processAddPersonalChat(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);

        } else if (status === 201) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    addSavedMessages(addSavedMessagesCommand: AddSavedMessagesCommand , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Chat/AddSavedMessages";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(addSavedMessagesCommand);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddSavedMessages(_response);
        });
    }

    protected processAddSavedMessages(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);

        } else if (status === 201) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    addUserToChat(addUserToChatCommand: AddUserToChatCommand , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Chat/AddUserToChat";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(addUserToChatCommand);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddUserToChat(_response);
        });
    }

    protected processAddUserToChat(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);

        } else if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    deleteUserFromChat(deleteUserFromChatCommand: DeleteUserFromChatCommand , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Chat/DeleteUserFromChat";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(deleteUserFromChatCommand);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "DELETE",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteUserFromChat(_response);
        });
    }

    protected processDeleteUserFromChat(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);

        } else if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export interface IRolesClient {
    getRoleByUserId(userId: string, chatId: string): Promise<RoleDto>;
    createRoleForChat(createRoleForChatCommand: CreateRoleForChatCommand): Promise<void>;
    changeRoleForUserById(changeRoleForUserByIdCommand: ChangeRoleForUserByIdCommand): Promise<void>;
}

export class RolesClient implements IRolesClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    getRoleByUserId(userId: string, chatId: string , cancelToken?: CancelToken | undefined): Promise<RoleDto> {
        let url_ = this.baseUrl + "/api/Roles/GetRoleByUserId?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (chatId === undefined || chatId === null)
            throw new Error("The parameter 'chatId' must be defined and cannot be null.");
        else
            url_ += "chatId=" + encodeURIComponent("" + chatId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRoleByUserId(_response);
        });
    }

    protected processGetRoleByUserId(response: AxiosResponse): Promise<RoleDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RoleDto.fromJS(resultData200, _mappings);
            return Promise.resolve<RoleDto>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RoleDto>(null as any);
    }

    createRoleForChat(createRoleForChatCommand: CreateRoleForChatCommand , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Roles/CreateRoleForChat";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createRoleForChatCommand);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateRoleForChat(_response);
        });
    }

    protected processCreateRoleForChat(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);

        } else if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    changeRoleForUserById(changeRoleForUserByIdCommand: ChangeRoleForUserByIdCommand , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Roles/ChangeRoleForUserById";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(changeRoleForUserByIdCommand);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeRoleForUserById(_response);
        });
    }

    protected processChangeRoleForUserById(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);

        } else if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export interface IUserClient {
    getAll(): Promise<MessengerUserDto[]>;
    getUser(userId: string): Promise<MessengerUserDto>;
    getAllChatsByUserId(userId: string): Promise<MessengerChatDto[]>;
    getAllChatsIdsByUserId(userId: string): Promise<string[]>;
    setNickNameById(setUserNickNameByIdCommand: SetUserNickNameByIdCommand): Promise<void>;
    deleteUser(deleteUserCommand: DeleteUserCommand): Promise<void>;
    addUser(addUserCommand: AddUserCommand): Promise<string>;
    changeDescription(changeUserDescriptionByIdCommand: ChangeUserDescriptionByIdCommand): Promise<void>;
    changeName(changeUserNameByIdCommand: ChangeUserNameByIdCommand): Promise<void>;
}

export class UserClient implements IUserClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    getAll(  cancelToken?: CancelToken | undefined): Promise<MessengerUserDto[]> {
        let url_ = this.baseUrl + "/api/User/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<MessengerUserDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MessengerUserDto.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<MessengerUserDto[]>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MessengerUserDto[]>(null as any);
    }

    getUser(userId: string , cancelToken?: CancelToken | undefined): Promise<MessengerUserDto> {
        let url_ = this.baseUrl + "/api/User/GetUser?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetUser(_response);
        });
    }

    protected processGetUser(response: AxiosResponse): Promise<MessengerUserDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MessengerUserDto.fromJS(resultData200, _mappings);
            return Promise.resolve<MessengerUserDto>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MessengerUserDto>(null as any);
    }

    getAllChatsByUserId(userId: string , cancelToken?: CancelToken | undefined): Promise<MessengerChatDto[]> {
        let url_ = this.baseUrl + "/api/User/GetAllChatsByUserId?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllChatsByUserId(_response);
        });
    }

    protected processGetAllChatsByUserId(response: AxiosResponse): Promise<MessengerChatDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MessengerChatDto.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<MessengerChatDto[]>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MessengerChatDto[]>(null as any);
    }

    getAllChatsIdsByUserId(userId: string , cancelToken?: CancelToken | undefined): Promise<string[]> {
        let url_ = this.baseUrl + "/api/User/GetAllChatsIdsByUserId?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllChatsIdsByUserId(_response);
        });
    }

    protected processGetAllChatsIdsByUserId(response: AxiosResponse): Promise<string[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<string[]>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string[]>(null as any);
    }

    setNickNameById(setUserNickNameByIdCommand: SetUserNickNameByIdCommand , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/User/SetNickNameById";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(setUserNickNameByIdCommand);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSetNickNameById(_response);
        });
    }

    protected processSetNickNameById(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);

        } else if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    deleteUser(deleteUserCommand: DeleteUserCommand , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/User/DeleteUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(deleteUserCommand);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteUser(_response);
        });
    }

    protected processDeleteUser(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);

        } else if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    addUser(addUserCommand: AddUserCommand , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/User/AddUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(addUserCommand);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddUser(_response);
        });
    }

    protected processAddUser(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);

        } else if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return Promise.resolve<string>(result201);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    changeDescription(changeUserDescriptionByIdCommand: ChangeUserDescriptionByIdCommand , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/User/ChangeDescription";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(changeUserDescriptionByIdCommand);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeDescription(_response);
        });
    }

    protected processChangeDescription(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);

        } else if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    changeName(changeUserNameByIdCommand: ChangeUserNameByIdCommand , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/User/ChangeName";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(changeUserNameByIdCommand);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeName(_response);
        });
    }

    protected processChangeName(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401, _mappings);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);

        } else if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class IdentityUserOfGuid implements IIdentityUserOfGuid {
    id!: string;
    userName!: string | undefined;
    normalizedUserName!: string | undefined;
    email!: string | undefined;
    normalizedEmail!: string | undefined;
    emailConfirmed!: boolean;
    passwordHash!: string | undefined;
    securityStamp!: string | undefined;
    concurrencyStamp!: string | undefined;
    phoneNumber!: string | undefined;
    phoneNumberConfirmed!: boolean;
    twoFactorEnabled!: boolean;
    lockoutEnd!: moment.Moment | undefined;
    lockoutEnabled!: boolean;
    accessFailedCount!: number;

    constructor(data?: IIdentityUserOfGuid) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.normalizedUserName = _data["normalizedUserName"];
            this.email = _data["email"];
            this.normalizedEmail = _data["normalizedEmail"];
            this.emailConfirmed = _data["emailConfirmed"];
            this.passwordHash = _data["passwordHash"];
            this.securityStamp = _data["securityStamp"];
            this.concurrencyStamp = _data["concurrencyStamp"];
            this.phoneNumber = _data["phoneNumber"];
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"];
            this.twoFactorEnabled = _data["twoFactorEnabled"];
            this.lockoutEnd = _data["lockoutEnd"] ? moment.parseZone(_data["lockoutEnd"].toString()) : <any>undefined;
            this.lockoutEnabled = _data["lockoutEnabled"];
            this.accessFailedCount = _data["accessFailedCount"];
        }
    }

    static fromJS(data: any, _mappings?: any): IdentityUserOfGuid | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<IdentityUserOfGuid>(data, _mappings, IdentityUserOfGuid);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["normalizedUserName"] = this.normalizedUserName;
        data["email"] = this.email;
        data["normalizedEmail"] = this.normalizedEmail;
        data["emailConfirmed"] = this.emailConfirmed;
        data["passwordHash"] = this.passwordHash;
        data["securityStamp"] = this.securityStamp;
        data["concurrencyStamp"] = this.concurrencyStamp;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
        data["twoFactorEnabled"] = this.twoFactorEnabled;
        data["lockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toISOString(true) : <any>undefined;
        data["lockoutEnabled"] = this.lockoutEnabled;
        data["accessFailedCount"] = this.accessFailedCount;
        return data;
    }
}

export interface IIdentityUserOfGuid {
    id: string;
    userName: string | undefined;
    normalizedUserName: string | undefined;
    email: string | undefined;
    normalizedEmail: string | undefined;
    emailConfirmed: boolean;
    passwordHash: string | undefined;
    securityStamp: string | undefined;
    concurrencyStamp: string | undefined;
    phoneNumber: string | undefined;
    phoneNumberConfirmed: boolean;
    twoFactorEnabled: boolean;
    lockoutEnd: moment.Moment | undefined;
    lockoutEnabled: boolean;
    accessFailedCount: number;
}

export class MessengerUser extends IdentityUserOfGuid implements IMessengerUser {
    name!: string;
    description!: string;

    constructor(data?: IMessengerUser) {
        super(data);
    }

    override init(_data?: any, _mappings?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static override fromJS(data: any, _mappings?: any): MessengerUser | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<MessengerUser>(data, _mappings, MessengerUser);
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        super.toJSON(data);
        return data;
    }
}

export interface IMessengerUser extends IIdentityUserOfGuid {
    name: string;
    description: string;
}

export class ProblemDetails implements IProblemDetails {
    type!: string | undefined;
    title!: string | undefined;
    status!: number | undefined;
    detail!: string | undefined;
    instance!: string | undefined;
    extensions!: { [key: string]: any; };

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
            if (_data["extensions"]) {
                this.extensions = {} as any;
                for (let key in _data["extensions"]) {
                    if (_data["extensions"].hasOwnProperty(key))
                        (<any>this.extensions)![key] = _data["extensions"][key];
                }
            }
        }
    }

    static fromJS(data: any, _mappings?: any): ProblemDetails | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ProblemDetails>(data, _mappings, ProblemDetails);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        if (this.extensions) {
            data["extensions"] = {};
            for (let key in this.extensions) {
                if (this.extensions.hasOwnProperty(key))
                    (<any>data["extensions"])[key] = this.extensions[key];
            }
        }
        return data;
    }
}

export interface IProblemDetails {
    type: string | undefined;
    title: string | undefined;
    status: number | undefined;
    detail: string | undefined;
    instance: string | undefined;
    extensions: { [key: string]: any; };
}

export class LoginRequest implements ILoginRequest {
    model!: LoginModel;

    constructor(data?: ILoginRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.model = _data["model"] ? LoginModel.fromJS(_data["model"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): LoginRequest | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<LoginRequest>(data, _mappings, LoginRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["model"] = this.model ? this.model.toJSON() : <any>undefined;
        return data;
    }
}

export interface ILoginRequest {
    model: LoginModel;
}

export class LoginModel implements ILoginModel {
    userName!: string | undefined;
    email!: string | undefined;
    password!: string;

    constructor(data?: ILoginModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any, _mappings?: any): LoginModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<LoginModel>(data, _mappings, LoginModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface ILoginModel {
    userName: string | undefined;
    email: string | undefined;
    password: string;
}

export class RegisterCommand implements IRegisterCommand {
    model!: RegisterModel;

    constructor(data?: IRegisterCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.model = _data["model"] ? RegisterModel.fromJS(_data["model"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): RegisterCommand | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<RegisterCommand>(data, _mappings, RegisterCommand);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["model"] = this.model ? this.model.toJSON() : <any>undefined;
        return data;
    }
}

export interface IRegisterCommand {
    model: RegisterModel;
}

export class RegisterModel implements IRegisterModel {
    userName!: string;
    name!: string;
    email!: string;
    password!: string;
    phoneNumber!: string;

    constructor(data?: IRegisterModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.phoneNumber = _data["phoneNumber"];
        }
    }

    static fromJS(data: any, _mappings?: any): RegisterModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<RegisterModel>(data, _mappings, RegisterModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["email"] = this.email;
        data["password"] = this.password;
        data["phoneNumber"] = this.phoneNumber;
        return data;
    }
}

export interface IRegisterModel {
    userName: string;
    name: string;
    email: string;
    password: string;
    phoneNumber: string;
}

export class AuthenticateResponse implements IAuthenticateResponse {
    userId!: string;
    validTo!: moment.Moment;

    constructor(data?: IAuthenticateResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.validTo = _data["validTo"] ? moment.parseZone(_data["validTo"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): AuthenticateResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<AuthenticateResponse>(data, _mappings, AuthenticateResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["validTo"] = this.validTo ? this.validTo.toISOString(true) : <any>undefined;
        return data;
    }
}

export interface IAuthenticateResponse {
    userId: string;
    validTo: moment.Moment;
}

export class RegisterAdminCommand implements IRegisterAdminCommand {
    model!: RegisterModel;

    constructor(data?: IRegisterAdminCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.model = _data["model"] ? RegisterModel.fromJS(_data["model"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): RegisterAdminCommand | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<RegisterAdminCommand>(data, _mappings, RegisterAdminCommand);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["model"] = this.model ? this.model.toJSON() : <any>undefined;
        return data;
    }
}

export interface IRegisterAdminCommand {
    model: RegisterModel;
}

export class MessengerChatDto implements IMessengerChatDto {
    id!: string;
    name!: string | undefined;
    description!: string | undefined;
    users!: string[];
    roles!: RoleDto[];

    constructor(data?: IMessengerChatDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(item);
            }
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(RoleDto.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): MessengerChatDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<MessengerChatDto>(data, _mappings, MessengerChatDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item);
        }
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        return data;
    }
}

export interface IMessengerChatDto {
    id: string;
    name: string | undefined;
    description: string | undefined;
    users: string[];
    roles: RoleDto[];
}

export class RoleDto implements IRoleDto {
    name!: string;
    canEditMessages!: ActionOption;
    canDeleteMessages!: ActionOption;
    canWriteMessages!: ActionOption;
    canReadMessages!: ActionOption;
    canAddUsers!: ActionOption;
    canDeleteUsers!: ActionOption;
    canPinMessages!: ActionOption;
    canSeeChannelMembers!: ActionOption;
    canInviteOtherUsers!: ActionOption;
    canEditChannelDescription!: ActionOption;
    canDeleteChat!: ActionOption;

    constructor(data?: IRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.name = _data["name"];
            this.canEditMessages = _data["canEditMessages"];
            this.canDeleteMessages = _data["canDeleteMessages"];
            this.canWriteMessages = _data["canWriteMessages"];
            this.canReadMessages = _data["canReadMessages"];
            this.canAddUsers = _data["canAddUsers"];
            this.canDeleteUsers = _data["canDeleteUsers"];
            this.canPinMessages = _data["canPinMessages"];
            this.canSeeChannelMembers = _data["canSeeChannelMembers"];
            this.canInviteOtherUsers = _data["canInviteOtherUsers"];
            this.canEditChannelDescription = _data["canEditChannelDescription"];
            this.canDeleteChat = _data["canDeleteChat"];
        }
    }

    static fromJS(data: any, _mappings?: any): RoleDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<RoleDto>(data, _mappings, RoleDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["canEditMessages"] = this.canEditMessages;
        data["canDeleteMessages"] = this.canDeleteMessages;
        data["canWriteMessages"] = this.canWriteMessages;
        data["canReadMessages"] = this.canReadMessages;
        data["canAddUsers"] = this.canAddUsers;
        data["canDeleteUsers"] = this.canDeleteUsers;
        data["canPinMessages"] = this.canPinMessages;
        data["canSeeChannelMembers"] = this.canSeeChannelMembers;
        data["canInviteOtherUsers"] = this.canInviteOtherUsers;
        data["canEditChannelDescription"] = this.canEditChannelDescription;
        data["canDeleteChat"] = this.canDeleteChat;
        return data;
    }
}

export interface IRoleDto {
    name: string;
    canEditMessages: ActionOption;
    canDeleteMessages: ActionOption;
    canWriteMessages: ActionOption;
    canReadMessages: ActionOption;
    canAddUsers: ActionOption;
    canDeleteUsers: ActionOption;
    canPinMessages: ActionOption;
    canSeeChannelMembers: ActionOption;
    canInviteOtherUsers: ActionOption;
    canEditChannelDescription: ActionOption;
    canDeleteChat: ActionOption;
}

export enum ActionOption {
    Unavailable = 0,
    Enabled = 1,
    Disabled = 2,
}

export class ChatUserDto implements IChatUserDto {
    chatUserName!: string;
    messengerUserId!: string;
    role!: RoleDto;

    constructor(data?: IChatUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.chatUserName = _data["chatUserName"];
            this.messengerUserId = _data["messengerUserId"];
            this.role = _data["role"] ? RoleDto.fromJS(_data["role"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): ChatUserDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ChatUserDto>(data, _mappings, ChatUserDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["chatUserName"] = this.chatUserName;
        data["messengerUserId"] = this.messengerUserId;
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        return data;
    }
}

export interface IChatUserDto {
    chatUserName: string;
    messengerUserId: string;
    role: RoleDto;
}

export class AddChannelCommand implements IAddChannelCommand {
    adminId!: string;
    name!: string;
    description!: string;

    constructor(data?: IAddChannelCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.adminId = _data["adminId"];
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any, _mappings?: any): AddChannelCommand | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<AddChannelCommand>(data, _mappings, AddChannelCommand);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adminId"] = this.adminId;
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }
}

export interface IAddChannelCommand {
    adminId: string;
    name: string;
    description: string;
}

export class AddGroupChatCommand implements IAddGroupChatCommand {
    adminId!: string;
    name!: string;
    description!: string;

    constructor(data?: IAddGroupChatCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.adminId = _data["adminId"];
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any, _mappings?: any): AddGroupChatCommand | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<AddGroupChatCommand>(data, _mappings, AddGroupChatCommand);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adminId"] = this.adminId;
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }
}

export interface IAddGroupChatCommand {
    adminId: string;
    name: string;
    description: string;
}

export class AddPersonalChatCommand implements IAddPersonalChatCommand {
    firstUserId!: string;
    secondUserId!: string;
    name!: string;
    description!: string;

    constructor(data?: IAddPersonalChatCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.firstUserId = _data["firstUserId"];
            this.secondUserId = _data["secondUserId"];
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any, _mappings?: any): AddPersonalChatCommand | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<AddPersonalChatCommand>(data, _mappings, AddPersonalChatCommand);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstUserId"] = this.firstUserId;
        data["secondUserId"] = this.secondUserId;
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }
}

export interface IAddPersonalChatCommand {
    firstUserId: string;
    secondUserId: string;
    name: string;
    description: string;
}

export class AddSavedMessagesCommand implements IAddSavedMessagesCommand {
    userId!: string;
    name!: string;
    description!: string;

    constructor(data?: IAddSavedMessagesCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any, _mappings?: any): AddSavedMessagesCommand | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<AddSavedMessagesCommand>(data, _mappings, AddSavedMessagesCommand);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }
}

export interface IAddSavedMessagesCommand {
    userId: string;
    name: string;
    description: string;
}

export class AddUserToChatCommand implements IAddUserToChatCommand {
    userId!: string;
    chatId!: string;

    constructor(data?: IAddUserToChatCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.chatId = _data["chatId"];
        }
    }

    static fromJS(data: any, _mappings?: any): AddUserToChatCommand | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<AddUserToChatCommand>(data, _mappings, AddUserToChatCommand);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["chatId"] = this.chatId;
        return data;
    }
}

export interface IAddUserToChatCommand {
    userId: string;
    chatId: string;
}

export class DeleteUserFromChatCommand implements IDeleteUserFromChatCommand {
    userId!: string;
    chatId!: string;

    constructor(data?: IDeleteUserFromChatCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.chatId = _data["chatId"];
        }
    }

    static fromJS(data: any, _mappings?: any): DeleteUserFromChatCommand | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<DeleteUserFromChatCommand>(data, _mappings, DeleteUserFromChatCommand);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["chatId"] = this.chatId;
        return data;
    }
}

export interface IDeleteUserFromChatCommand {
    userId: string;
    chatId: string;
}

export class CreateRoleForChatCommand implements ICreateRoleForChatCommand {
    role!: RoleDto;
    chatId!: string;

    constructor(data?: ICreateRoleForChatCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.role = _data["role"] ? RoleDto.fromJS(_data["role"], _mappings) : <any>undefined;
            this.chatId = _data["chatId"];
        }
    }

    static fromJS(data: any, _mappings?: any): CreateRoleForChatCommand | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CreateRoleForChatCommand>(data, _mappings, CreateRoleForChatCommand);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        data["chatId"] = this.chatId;
        return data;
    }
}

export interface ICreateRoleForChatCommand {
    role: RoleDto;
    chatId: string;
}

export class ChangeRoleForUserByIdCommand implements IChangeRoleForUserByIdCommand {
    userId!: string;
    chatId!: string;
    role!: RoleDto;

    constructor(data?: IChangeRoleForUserByIdCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.chatId = _data["chatId"];
            this.role = _data["role"] ? RoleDto.fromJS(_data["role"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): ChangeRoleForUserByIdCommand | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ChangeRoleForUserByIdCommand>(data, _mappings, ChangeRoleForUserByIdCommand);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["chatId"] = this.chatId;
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        return data;
    }
}

export interface IChangeRoleForUserByIdCommand {
    userId: string;
    chatId: string;
    role: RoleDto;
}

export class MessengerUserDto implements IMessengerUserDto {
    id!: string;
    name!: string | undefined;
    userName!: string | undefined;
    description!: string | undefined;

    constructor(data?: IMessengerUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.userName = _data["userName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any, _mappings?: any): MessengerUserDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<MessengerUserDto>(data, _mappings, MessengerUserDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["userName"] = this.userName;
        data["description"] = this.description;
        return data;
    }
}

export interface IMessengerUserDto {
    id: string;
    name: string | undefined;
    userName: string | undefined;
    description: string | undefined;
}

export class SetUserNickNameByIdCommand implements ISetUserNickNameByIdCommand {
    userId!: string;
    userName!: string;

    constructor(data?: ISetUserNickNameByIdCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any, _mappings?: any): SetUserNickNameByIdCommand | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<SetUserNickNameByIdCommand>(data, _mappings, SetUserNickNameByIdCommand);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        return data;
    }
}

export interface ISetUserNickNameByIdCommand {
    userId: string;
    userName: string;
}

export class DeleteUserCommand implements IDeleteUserCommand {
    userId!: string;

    constructor(data?: IDeleteUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any, _mappings?: any): DeleteUserCommand | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<DeleteUserCommand>(data, _mappings, DeleteUserCommand);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        return data;
    }
}

export interface IDeleteUserCommand {
    userId: string;
}

export class AddUserCommand implements IAddUserCommand {
    name!: string;
    nickName!: string;
    description!: string;

    constructor(data?: IAddUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.name = _data["name"];
            this.nickName = _data["nickName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any, _mappings?: any): AddUserCommand | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<AddUserCommand>(data, _mappings, AddUserCommand);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["nickName"] = this.nickName;
        data["description"] = this.description;
        return data;
    }
}

export interface IAddUserCommand {
    name: string;
    nickName: string;
    description: string;
}

export class ChangeUserDescriptionByIdCommand implements IChangeUserDescriptionByIdCommand {
    userId!: string;
    description!: string;

    constructor(data?: IChangeUserDescriptionByIdCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any, _mappings?: any): ChangeUserDescriptionByIdCommand | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ChangeUserDescriptionByIdCommand>(data, _mappings, ChangeUserDescriptionByIdCommand);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["description"] = this.description;
        return data;
    }
}

export interface IChangeUserDescriptionByIdCommand {
    userId: string;
    description: string;
}

export class ChangeUserNameByIdCommand implements IChangeUserNameByIdCommand {
    userId!: string;
    name!: string;

    constructor(data?: IChangeUserNameByIdCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any, _mappings?: any): ChangeUserNameByIdCommand | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ChangeUserNameByIdCommand>(data, _mappings, ChangeUserNameByIdCommand);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["name"] = this.name;
        return data;
    }
}

export interface IChangeUserNameByIdCommand {
    userId: string;
    name: string;
}

function jsonParse(json: any, reviver?: any) {
    json = JSON.parse(json, reviver);

    var byid: any = {};
    var refs: any = [];
    json = (function recurse(obj: any, prop?: any, parent?: any) {
        if (typeof obj !== 'object' || !obj)
            return obj;
        
        if ("$ref" in obj) {
            let ref = obj.$ref;
            if (ref in byid)
                return byid[ref];
            refs.push([parent, prop, ref]);
            return undefined;
        } else if ("$id" in obj) {
            let id = obj.$id;
            delete obj.$id;
            if ("$values" in obj)
                obj = obj.$values;
            byid[id] = obj;
        }
        
        if (Array.isArray(obj)) {
            obj = obj.map((v, i) => recurse(v, i, obj));
        } else {
            for (var p in obj) {
                if (obj.hasOwnProperty(p) && obj[p] && typeof obj[p] === 'object')
                    obj[p] = recurse(obj[p], p, obj);
            }
        }

        return obj;
    })(json);

    for (let i = 0; i < refs.length; i++) {
        const ref = refs[i];
        ref[0][ref[1]] = byid[ref[2]];
    }

    return json;
}

function createInstance<T>(data: any, mappings: any, type: any): T | null {
  if (!mappings)
    mappings = [];
  if (!data)
    return null;

  const mappingIndexName = "__mappingIndex";
  if (data[mappingIndexName])
    return <T>mappings[data[mappingIndexName]].target;

  data[mappingIndexName] = mappings.length;

  let result: any = new type();
  mappings.push({ source: data, target: result });
  result.init(data, mappings);
  return result;
}

export class Do_Svyazi_User_ApiClient_Exception extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isDo_Svyazi_User_ApiClient_Exception = true;

    static isDo_Svyazi_User_ApiClient_Exception(obj: any): obj is Do_Svyazi_User_ApiClient_Exception {
        return obj.isDo_Svyazi_User_ApiClient_Exception === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    throw new Do_Svyazi_User_ApiClient_Exception(message, status, response, headers, result);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}